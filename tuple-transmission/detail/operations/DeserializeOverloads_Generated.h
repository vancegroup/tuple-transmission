/** @file
	@brief Header AUTO-GENERATED by variadicGenerate.lua on input DeserializedOverloads.gen.lua to avoid doing crazy preprocessor things

	DO NOT EDIT THIS FILE DIRECTLY - instead, edit the script that generates it.

	@date 2012

	@author
	Ryan Pavlik
	<rpavlik@iastate.edu> and <abiryan@ryand.net>
	http://academic.cleardefinition.com/
	Iowa State University Virtual Reality Applications Center
	Human-Computer Interaction Graduate Program
*/

//          Copyright Iowa State University 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once
#ifndef INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13
#define INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13

// Internal Includes
#include "../../MessageType.h"

// Library/third-party includes
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/functional/invocation/invoke_procedure.hpp>
#include <boost/mpl/size.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/identity.hpp>
#include <boost/mpl/equal_to.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/utility/enable_if.hpp>

// Standard includes
// - none

namespace transmission {
	namespace detail {
		namespace operations {
			namespace generated {
				namespace mpl = boost::mpl;
				namespace fusion = boost::fusion;
				using boost::enable_if;
				using boost::is_same;
				typedef mpl::int_<9> DeserializeMaxArity;

				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<1>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1>(
					        MessageTag<MessageType>(), a1
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<2>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2>(
					        MessageTag<MessageType>(), a1, a2
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<3>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3>(
					        MessageTag<MessageType>(), a1, a2, a3
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<4>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4>(
					        MessageTag<MessageType>(), a1, a2, a3, a4
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<5>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					typedef typename mpl::at_c<MessageType, 4>::type T5;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					T5 a5 = Policy::template unbuffer(mpl::identity<T5>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4, T5>(
					        MessageTag<MessageType>(), a1, a2, a3, a4, a5
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<6>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					typedef typename mpl::at_c<MessageType, 4>::type T5;
					typedef typename mpl::at_c<MessageType, 5>::type T6;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					T5 a5 = Policy::template unbuffer(mpl::identity<T5>(), it);
					T6 a6 = Policy::template unbuffer(mpl::identity<T6>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4, T5, T6>(
					        MessageTag<MessageType>(), a1, a2, a3, a4, a5, a6
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<7>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					typedef typename mpl::at_c<MessageType, 4>::type T5;
					typedef typename mpl::at_c<MessageType, 5>::type T6;
					typedef typename mpl::at_c<MessageType, 6>::type T7;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					T5 a5 = Policy::template unbuffer(mpl::identity<T5>(), it);
					T6 a6 = Policy::template unbuffer(mpl::identity<T6>(), it);
					T7 a7 = Policy::template unbuffer(mpl::identity<T7>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4, T5, T6, T7>(
					        MessageTag<MessageType>(), a1, a2, a3, a4, a5, a6, a7
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<8>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					typedef typename mpl::at_c<MessageType, 4>::type T5;
					typedef typename mpl::at_c<MessageType, 5>::type T6;
					typedef typename mpl::at_c<MessageType, 6>::type T7;
					typedef typename mpl::at_c<MessageType, 7>::type T8;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					T5 a5 = Policy::template unbuffer(mpl::identity<T5>(), it);
					T6 a6 = Policy::template unbuffer(mpl::identity<T6>(), it);
					T7 a7 = Policy::template unbuffer(mpl::identity<T7>(), it);
					T8 a8 = Policy::template unbuffer(mpl::identity<T8>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4, T5, T6, T7, T8>(
					        MessageTag<MessageType>(), a1, a2, a3, a4, a5, a6, a7, a8
					    )
					);
				}
				template<typename MessageType, typename Policy, typename Function, typename Iterator>
				void
				deserialize(Function & f, Iterator & it, typename enable_if< mpl::equal_to<mpl::int_<9>, typename mpl::size<MessageType>::type>, void *>::type = NULL) {
					typedef typename mpl::at_c<MessageType, 0>::type T1;
					typedef typename mpl::at_c<MessageType, 1>::type T2;
					typedef typename mpl::at_c<MessageType, 2>::type T3;
					typedef typename mpl::at_c<MessageType, 3>::type T4;
					typedef typename mpl::at_c<MessageType, 4>::type T5;
					typedef typename mpl::at_c<MessageType, 5>::type T6;
					typedef typename mpl::at_c<MessageType, 6>::type T7;
					typedef typename mpl::at_c<MessageType, 7>::type T8;
					typedef typename mpl::at_c<MessageType, 8>::type T9;
					T1 a1 = Policy::template unbuffer(mpl::identity<T1>(), it);
					T2 a2 = Policy::template unbuffer(mpl::identity<T2>(), it);
					T3 a3 = Policy::template unbuffer(mpl::identity<T3>(), it);
					T4 a4 = Policy::template unbuffer(mpl::identity<T4>(), it);
					T5 a5 = Policy::template unbuffer(mpl::identity<T5>(), it);
					T6 a6 = Policy::template unbuffer(mpl::identity<T6>(), it);
					T7 a7 = Policy::template unbuffer(mpl::identity<T7>(), it);
					T8 a8 = Policy::template unbuffer(mpl::identity<T8>(), it);
					T9 a9 = Policy::template unbuffer(mpl::identity<T9>(), it);
					fusion::invoke_procedure<Function &>(
					    f,
					    fusion::vector< MessageTag<MessageType> const&, T1, T2, T3, T4, T5, T6, T7, T8, T9>(
					        MessageTag<MessageType>(), a1, a2, a3, a4, a5, a6, a7, a8, a9
					    )
					);
				}
			} // end of namespace generated
		} // end of namespace operations
	} // end of namespace detail
} // end of namespace transmission
#endif // INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13

