/** @file
	@brief Header AUTO-GENERATED by variadicGenerate.lua on input DeserializedOverloads.gen.lua to avoid doing crazy preprocessor things

	@date 2012

	@author
	Ryan Pavlik
	<rpavlik@iastate.edu> and <abiryan@ryand.net>
	http://academic.cleardefinition.com/
	Iowa State University Virtual Reality Applications Center
	Human-Computer Interaction Graduate Program
*/

//          Copyright Iowa State University 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once
#ifndef INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13
#define INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13

// Internal Includes
// - none

// Library/third-party includes
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/functional/invocation/invoke_function_object.hpp>
#include <boost/mpl/size.hpp>
#include <boost/mpl/int.hpp>
#include <boost/utility/is_same.hpp>
#include <boost/enable_if.hpp>

// Standard includes
// - none

namespace transmission {
	namespace detail {
		namespace operations {
			namespace generated {
				namespace mpl = boost::mpl;
				namespace fusion = boost::fusion;
				using boost::enable_if;
				using boost::is_same;

				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<1> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<1> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					T1 a1 = Policy::template unbuffer<T1>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1>(
							a1
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<2> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<2> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2>(
							a1, a2
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<3> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<3> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3>(
							a1, a2, a3
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<4> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<4> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4>(
							a1, a2, a3, a4
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<5> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<5> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5>(
							a1, a2, a3, a4, a5
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<6> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<6> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					typedef typename mpl::at_c<Sequence, 6>::type T6;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					T6 a6 = Policy::template unbuffer<T6>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5, T6>(
							a1, a2, a3, a4, a5, a6
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<7> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<7> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					typedef typename mpl::at_c<Sequence, 6>::type T6;
					typedef typename mpl::at_c<Sequence, 7>::type T7;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					T6 a6 = Policy::template unbuffer<T6>(it);
					T7 a7 = Policy::template unbuffer<T7>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5, T6, T7>(
							a1, a2, a3, a4, a5, a6, a7
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<8> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<8> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					typedef typename mpl::at_c<Sequence, 6>::type T6;
					typedef typename mpl::at_c<Sequence, 7>::type T7;
					typedef typename mpl::at_c<Sequence, 8>::type T8;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					T6 a6 = Policy::template unbuffer<T6>(it);
					T7 a7 = Policy::template unbuffer<T7>(it);
					T8 a8 = Policy::template unbuffer<T8>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5, T6, T7, T8>(
							a1, a2, a3, a4, a5, a6, a7, a8
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<9> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<9> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					typedef typename mpl::at_c<Sequence, 6>::type T6;
					typedef typename mpl::at_c<Sequence, 7>::type T7;
					typedef typename mpl::at_c<Sequence, 8>::type T8;
					typedef typename mpl::at_c<Sequence, 9>::type T9;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					T6 a6 = Policy::template unbuffer<T6>(it);
					T7 a7 = Policy::template unbuffer<T7>(it);
					T8 a8 = Policy::template unbuffer<T8>(it);
					T9 a9 = Policy::template unbuffer<T9>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5, T6, T7, T8, T9>(
							a1, a2, a3, a4, a5, a6, a7, a8, a9
						)
					);
				}
				template<typename Sequence, typename Policy, typename Function, typename Iterator>
				typename enable_if<is_same<typename mpl::size<Sequence>::type, mpl::int_<10> >, void>::type
				deserialize(Function & f, Iterator & it, mpl::int_<10> &) {
					typedef typename mpl::at_c<Sequence, 1>::type T1;
					typedef typename mpl::at_c<Sequence, 2>::type T2;
					typedef typename mpl::at_c<Sequence, 3>::type T3;
					typedef typename mpl::at_c<Sequence, 4>::type T4;
					typedef typename mpl::at_c<Sequence, 5>::type T5;
					typedef typename mpl::at_c<Sequence, 6>::type T6;
					typedef typename mpl::at_c<Sequence, 7>::type T7;
					typedef typename mpl::at_c<Sequence, 8>::type T8;
					typedef typename mpl::at_c<Sequence, 9>::type T9;
					typedef typename mpl::at_c<Sequence, 10>::type T10;
					T1 a1 = Policy::template unbuffer<T1>(it);
					T2 a2 = Policy::template unbuffer<T2>(it);
					T3 a3 = Policy::template unbuffer<T3>(it);
					T4 a4 = Policy::template unbuffer<T4>(it);
					T5 a5 = Policy::template unbuffer<T5>(it);
					T6 a6 = Policy::template unbuffer<T6>(it);
					T7 a7 = Policy::template unbuffer<T7>(it);
					T8 a8 = Policy::template unbuffer<T8>(it);
					T9 a9 = Policy::template unbuffer<T9>(it);
					T10 a10 = Policy::template unbuffer<T10>(it);
					fusion::invoke_function_object<Function &>(
						f,
						fusion::vector< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
							a1, a2, a3, a4, a5, a6, a7, a8, a9, a10
						)
					);
				}
			} // end of namespace generated
		} // end of namespace operations
	} // end of namespace detail
} // end of namespace transmission
#endif // INCLUDED_DeserializeOverloads_Generated_h_GUID_77b2ed7c_5501_4195_8d2c_dac91b47cf13

